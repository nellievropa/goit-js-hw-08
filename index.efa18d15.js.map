{"mappings":"AAyIA,MAAMA,EAAUC,SAASC,cAAc,YACjCC,EAAUF,SAASC,cAAc,eACvCF,EAAQI,mBAAmB,YAAaC,KACxCL,EAAQM,iBAAiB,SA0BzB,SAAiBC,GACb,GAAKA,EAAIC,OAAOC,YAcZC,MAAM,iBAdmB,CACzBH,EAAIC,OAAOC,YAAcE,EACzBC,QAAQC,IAAIN,EAAIC,QAChB,MAAMM,EAAKC,OAAOR,EAAIC,OAAOQ,QAAQF,IAEvB,MAAXH,EACCM,EAAMC,KAAKJ,GAEXK,EAAMD,KAAKJ,GAEhBF,QAAQQ,IAAI,QAASH,GACrBL,QAAQQ,IAAI,QAASD,GACpBR,EAAoB,MAAXA,EAAiB,IAAM,G,KAtCxCR,EAAQG,iBAAiB,SA4CzB,WACIK,EAAS,IACTX,EAAQqB,UAAYhB,G,IA7CxB,IAAIM,EAAS,IAEkB,MAAzBM,EAAQ,GACRE,EAAO,GAab,SAASd,IACL,IAAIiB,EAAS,GACb,IAAK,IAAIC,EAAI,EAAGA,GAAK,EAAGA,GAAK,EACjCD,GAAU,8BAA8BC,YAEpC,OAAOD,C","sources":["src/js/index.js"],"sourcesContent":["// // 1 отримали контейнер з HTML\n// const container = document.querySelector('.js-content')\n// // console.log(container);\n// // 2 створюємо гравця Х по дефолту\n// let player = \"X\";\n// // 3 створимо історії ходів двох гравців і їх пусті масиви, які будуть заповнюватися даними\n// // щоб легко було очистити поля задамо змінні через Let а не const\n// let historyX = [];\n// let historyO = [];\n// // 4 створюємо масив масивів всіх виграшних комбінацй\n// const wins = [\n//     [1, 2, 3],\n//     [3, 6, 9],\n//     [4, 5, 6],\n//     [7, 8, 9],\n//     [1, 4, 7],\n//     [2, 5, 8],\n//     [1, 5, 9],\n//     [3, 5, 7],\n// ];\n// //5 Створюємо функцію генерування розмітки\n// //6 створюємо  змінну markup, в яку кожен раз буде додаватися нове поле ігрове div, у якого клас js-item - щоб первірити куди ми клікнули і data-id -щоб записувати історію ходів\n// // і переносимо її функцію createMarkup()\n// // створюємо нову функцию, щоб можна було перевикористовувати, і переносимо дані в неї\n// function createMarkup() {\n//     let markup = \"\";\n//     for (let i = 1; i < 10; i += 1){\n//         markup += `<div class=\"item js-item\" data-id=\"${i}\"></div>`;\n//     }\n//     // console.log(markup);\n//     //7 наповнили наш HTML контейнер квадратиками!!\n//     container.innerHTML = markup;\n// }\n// // і зразу її викликаємо\n// createMarkup();\n\n// //8 щоб знати, на який квадратик клікаєм на БАТЬКІВСЬКИЙ елемент вішаємо прослуховувача\n// container.addEventListener('click', onClick);\n\n// function onClick(evt) {\n//     //9 Делегували подій робимо через Деструктуризацію таргета - коли побвачили, що елемент часто повторюється- робимо змінну і прибираємо його з коду\n//     const { target } = evt;\n// // якщо ми клікнули НЕ на квадратик, то одразу виходимо\n// // 10 перевіряємо якщо наш елемент не містить класу \"js-item\" або якщо його текстовий контент зайнятий!!!- то зразу виходимо \n//     if (!target.classList.contains(\"js-item\") || target.textContent) {\n//         return;\n//     }\n//     // а потім другу умову додаємо через або в перший иф\n//     // ця умова не дає змінювати Х на 0 на ОДНІЙ клітинці!!!\n//     // якщо клітинка пуста - дозволяємо хід, якщо зайнята - не дозволяємо\n//     // if (etarget.textContent) {\n//     //     return;\n//     // }\n//     // щоб дізнатись ID клітинки на яку клікнули- шукаємо її номер, зразу для обох ігроків\n//      // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа тому приводимо його до числа \n\n//     // const { id } = Number(target.dataset); - так не працює, тому змінюємо на \n//     // 11 Дістаємо id кожної клітинки і приводимо його до числа\n//     const  id  = Number(target.dataset.id);\n//     // створимо змінну для переможця\n// let result = false;\n// // 23 робимо змінну на перевірку кількості ходів \n// const isEndGame = historyO.length + historyX.length === 9;\n//     // 12 Ідемо і перевіряємо, якщо поточний гравець здійснив хід- пушим його в історію\n//     // нам треба визначитись, хто робить хід, тому створюємо умову\n//     if (player === \"X\") {\n//         historyX.push(id);\n//         // 13 Змінній result присвоюємо результат виконання функції isWinner\n//         result = isWinner(historyX)\n//     } else {\n//         historyO.push(id);\n//         result = isWinner(historyO)\n//     }\n//       // текстовий контент елемента, по якому клікнули = Х - це перший ход\n//     //   17 перевизначаємо хід для наступного гравця\n//       target.textContent = player;\n//     //   18 якщо результат TRUE - у нас є переможець і ми підставляємо його в результат ${player}\n//     if (result) {\n//         console.log(`Winner is ${player}`);\n//         // 19 і перезавантажуємо гру функцією resetGame(), яка прописана нижче\n//         resetGame();\n//         return;\n//         // 22 якщо переможця немає, але всі клітинки запонились\n//         // перевіряємо кількість ходів і щоб не робити таку довгу умову виносимо цю перевірку в змінну\n//         // а тут тоді перевіряємо на булеве значення\n//     }else if(isEndGame) {\n// console.log(`Try again!`);\n// resetGame();\n// return;\n//     }\n// // отримуємо просто номер  const {id} = target.dataset\n//     // але з data atributa  він прийде у форматі рядка, а наші масиви- то числа \n//     // console.log('X', historyX);\n//     //  console.log('0', history0);\n//     // console.log( isWinner(historyX));\n  \n// //21 якщо переможця не визначено то ми змінюємо чергу ходу\n// //  змінюємо чергу ходу на 0: якщо був Х змінюємо на 0\n// // перевизначаємо player = \n//     player = player === 'X' ? 'O' : 'X';\n\n//     // currentTarget-батько(весь контейнер\n//     // target-кожен маленький квадратик)\n//     // console.log(evt.currentTarget);\n//     // console.log(evt.target)\n// }\n// // щоб визначити, хто виграв нам потрібно знати ID клітинки!!!\n// // тому ми його додаємо в код вище!\n\n// // створимо функцію, яка буде перевіряти чи виграв хтось з гравців\n// // порівнювати з виграшими комбінаціями\n// // в функцыю приходить історыя ходів в вигляді масива\n// // 14 в цій функції перевіряємо чи історія ходів є виграшною!\n// function isWinner(arr) {\n// //15 ми  перебираємо масив wins з допомогою методу some\n// // перевіряємо чи є в історії ходів подібна комбінація цифр\n// // 16 наша умова для методу some це результат виконання методу every\n//                     //   [2, 5, 8]\n// return wins.some((item) => item.every(id => arr.includes(id))); \n//                     //every повертає  TRUE тільки якщо ВСІ елементи задовільнили умові\n// }\n\n// // щоб очищати ігрові поля створимо функцію resetGame і викличемо її в тому разі коли є переможець\n// function resetGame(){\n//     // 20.1 запускає функцію створення розмітки\n//     createMarkup();\n//     // 20.2 визначає пустим масивом історії Х і О\n//     historyX = [];\n//     historyO = [];\n//     // 20.3 повертаемо до початкового плеєра Х\n//     player = \"X\";\n// }\n\n\n\n\n\nconst content = document.querySelector('.content')\nconst restart = document.querySelector('.js-restart');\ncontent.insertAdjacentHTML('beforeend', createMarkup())\ncontent.addEventListener('click', onClick);\nrestart.addEventListener('click', onRestart);\nlet player = 'X';\n// масиви для збереження даних про ходи\nconst stepX = [];\nconst stepO =[];\n\nconst win = [\n    [1, 2, 3],\n    [3, 6, 9],\n    [4, 5, 6],\n    [7, 8, 9],\n    [1, 4, 7],\n    [2, 5, 8],\n    [1, 5, 9],\n    [3, 5, 7]\n];\n\nfunction createMarkup() {\n    let markup = '';\n    for (let i = 1; i <= 9; i += 1)  {\nmarkup += `<div class=\"item\" data-id=\"${i}\"></div>`\n    }\n    return markup;\n}\n\nfunction onClick(evt) {\n    if (!evt.target.textContent) {\n        evt.target.textContent = player;\n        console.dir(evt.target);\n        const id = Number(evt.target.dataset.id);\n      \n        if(player === \"X\") {\n            stepX.push(id)\n        }else {\n            stepO.push(id)\n        }\n       console.log('stepX', stepX);\n       console.log('stepO', stepO);\n        player = player === \"X\" ? \"0\" : \"X\";        \n    } else {\n        alert('Change!!!')\n    }\n}\n\nfunction onRestart() {\n    player = \"X\";\n    content.innerHTML = createMarkup();\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// const session = document.querySelector('.session');\n// const local = document.querySelector('.local');\n// const remove = document.querySelector('.remove');\n\n// session.addEventListener('click', onSession);\n// const arr =[1,2,3,4,5,]\n// function onSession() {\n//     // sessionStorage.setItem('session', 'hello session');\n//     const data = JSON.parse(localStorage.getItem('local')) || [];\n//     console.log(data);\n//     // якщо це- const arr =[1,2,3,4,5,]-масив то й тут додаємо пустий масив \n//     // const resp = JSON.parse(data)\n//     // console.log(resp);\n//     // sessionStorage.setItem('session', arr);\n\n//     data.forEach(element => {\n//         console.log(element);\n//     });\n// }\n\n// local.addEventListener('click', onLocal);\n\n// function onLocal() {\n//     // приводимо до рядка\n//     localStorage.setItem('local', JSON.stringify(arr));\n//     localStorage.setItem('local1', JSON.stringify(arr));\n//     localStorage.setItem('local2', JSON.stringify(arr));\n// }\n\n// remove.addEventListener('click', onRemove)\n\n// function onRemove() {\n// // localStorage.removeItem('local');\n// localStorage.clear();\n// }"],"names":["$85a5f86b715fe7db$var$content","document","querySelector","$85a5f86b715fe7db$var$restart","insertAdjacentHTML","$85a5f86b715fe7db$var$createMarkup","addEventListener","evt","target","textContent","alert","$85a5f86b715fe7db$var$player","console","dir","id","Number","dataset","$85a5f86b715fe7db$var$stepX","push","$85a5f86b715fe7db$var$stepO","log","innerHTML","markup","i"],"version":3,"file":"index.efa18d15.js.map"}